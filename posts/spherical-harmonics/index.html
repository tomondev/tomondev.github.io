<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tom">
<meta name="dcterms.date" content="2025-09-01">

<title>Spherical Harmonics and 3D Gaussian Splatting Rendering – On Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-d561ea539f5bb5e84c4ef8cda8106a7a.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">On Notes</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Spherical Harmonics and 3D Gaussian Splatting Rendering</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Tom </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 1, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>In the example of <a href="https://tomondev.github.io/posts/image-2dgs/">2D Gaussian Splatting</a>, we use a vector <span class="math inline">\(c\in\mathbb{R}^3\)</span> to represent the color of a 2D Gaussian. In the 2D case, a Gaussian shows the same color regardless of the viewing direction. In 3D Gaussian Splatting (3DGS), however, it is common to model view-dependent appearance (e.g., Lambertian or glossy surfaces). Therefore, we cannot assign fixed RGB values to each 3D Gaussian, because the color must change based on the viewer’s perspective.</p>
<p>Intuitively, modeling arbitrary view-dependent appearance requires defining a function on the surface of a sphere. While a straightforward approach is to discretize the sphere with a grid and assign a value to each cell, this method introduces a prohibitive number of parameters for each Gaussian—not to mention that we may have tens of thousands of Gaussians in a scene.</p>
<p>A natural approach is to parameterize the spherical function using a set of basis functions. Just as one-dimensional periodic functions on a circle can be expressed as a sum of circular functions (sines and cosines) via Fourier series, spherical functions can be represented as a sum of <a href="https://en.wikipedia.org/wiki/Spherical_harmonics">spherical harmonics</a>, which are a set of orthogonal functions defined on the surface of a sphere.</p>
</section>
<section id="spherical-harmonics" class="level1">
<h1>Spherical Harmonics</h1>
<p>Given spherical coordinates <span class="math inline">\((\theta,\varphi)\)</span> on a unit sphere, spherical harmonics (SH) are defined as <span class="math display">\[
Y_{l}^{m}(\theta, \varphi) = \sqrt{\frac{2l+1}{4\pi} \frac{(l-m)!}{(l+m)!}} P_{l}^{m}(\cos\theta) e^{i m \varphi}
\]</span> where:</p>
<ul>
<li><p><span class="math inline">\(l\)</span> is the degree (an integer <span class="math inline">\(\ge 0\)</span>).</p></li>
<li><p><span class="math inline">\(m\)</span> is an integer, <span class="math inline">\(−l\le m\le l\)</span>.</p></li>
<li><p><span class="math inline">\(\theta\)</span> is the polar angle (colatitude), <span class="math inline">\(0\le\theta\le\pi\)</span>.</p></li>
<li><p><span class="math inline">\(\varphi\)</span> is the azimuthal angle (longitude), <span class="math inline">\(0\le\varphi&lt;2\pi\)</span>.</p></li>
<li><p><span class="math inline">\(P_l^m(x)\)</span> are the <a href="https://en.wikipedia.org/wiki/Associated_Legendre_polynomials#The_first_few_associated_Legendre_functions">Associated Legendre Polynomials</a>.</p></li>
</ul>
<p>Notice that SH are complex-valued functions. Using the definition above, we can derive <span class="math inline">\(Y_l^m\)</span> for any given <span class="math inline">\(l\)</span> and <span class="math inline">\(m\)</span>. For example:</p>
<section id="l0" class="level3">
<h3 class="anchored" data-anchor-id="l0"><span class="math inline">\(l=0\)</span></h3>
<p><span class="math display">\[
Y_0^0(\theta, \varphi) = \frac{1}{2}\sqrt{\frac{1}{\pi}}
\]</span></p>
</section>
<section id="l1" class="level3">
<h3 class="anchored" data-anchor-id="l1"><span class="math inline">\(l=1\)</span></h3>
<p><span class="math display">\[
\begin{align}
Y_1^{-1}(\theta, \varphi) &amp;= \frac{1}{2}\sqrt{\frac{3}{2\pi}} \cdot \mathrm{e}^{-i\varphi} \cdot \sin \theta \\
Y_1^0(\theta, \varphi) &amp;= \frac{1}{2}\sqrt{\frac{3}{\pi}} \cdot \cos \theta \\
Y_1^1(\theta, \varphi) &amp;= -\frac{1}{2}\sqrt{\frac{3}{2\pi}} \cdot \mathrm{e}^{i\varphi} \cdot \sin \theta
\end{align}
\]</span></p>
</section>
<section id="l2" class="level3">
<h3 class="anchored" data-anchor-id="l2"><span class="math inline">\(l=2\)</span></h3>
<p><span class="math display">\[
\begin{align}
Y_2^{-2}(\theta, \varphi) &amp;= \frac{1}{4}\sqrt{\frac{15}{2\pi}} \cdot \mathrm{e}^{-2i\varphi} \cdot \sin^2 \theta \\
Y_2^{-1}(\theta, \varphi) &amp;= \frac{1}{2}\sqrt{\frac{15}{2\pi}} \cdot \mathrm{e}^{-i\varphi} \cdot \sin \theta \cdot \cos \theta \\
Y_2^0(\theta, \varphi) &amp;= \frac{1}{4}\sqrt{\frac{5}{\pi}} (3 \cos^2 \theta - 1) \\
Y_2^1(\theta, \varphi) &amp;= -\frac{1}{2}\sqrt{\frac{15}{2\pi}} \cdot \mathrm{e}^{i\varphi} \cdot \sin \theta \cdot \cos \theta \\
Y_2^2(\theta, \varphi) &amp;= \frac{1}{4}\sqrt{\frac{15}{2\pi}} \cdot \mathrm{e}^{2i\varphi} \cdot \sin^2 \theta
\end{align}
\]</span></p>
<p><span class="math inline">\(l=3\)</span> <span class="math display">\[
\begin{align}
Y_3^{-3}(\theta, \varphi) &amp;= \frac{1}{8} \sqrt{\frac{35}{\pi}} \cdot e^{-3i\varphi} \cdot \sin^3 \theta \\
Y_3^{-2}(\theta, \varphi) &amp;= \frac{1}{4} \sqrt{\frac{105}{2\pi}} \cdot e^{-2i\varphi} \cdot \sin^2 \theta \cdot \cos \theta \\
Y_3^{-1}(\theta, \varphi) &amp;= \frac{1}{8} \sqrt{\frac{21}{\pi}} \cdot e^{-i\varphi} \cdot \sin \theta \cdot (5 \cos^2 \theta - 1) \\
Y_3^{0}(\theta, \varphi) &amp;= \frac{1}{4} \sqrt{\frac{7}{\pi}} \cdot (5 \cos^3 \theta - 3 \cos \theta) \\
Y_3^{1}(\theta, \varphi) &amp;= -\frac{1}{8} \sqrt{\frac{21}{\pi}} \cdot e^{i\varphi} \cdot \sin \theta \cdot (5 \cos^2 \theta - 1) \\
Y_3^{2}(\theta, \varphi) &amp;= \frac{1}{4} \sqrt{\frac{105}{2\pi}} \cdot e^{2i\varphi} \cdot \sin^2 \theta \cdot \cos \theta \\
Y_3^{3}(\theta, \varphi) &amp;= -\frac{1}{8} \sqrt{\frac{35}{\pi}} \cdot e^{3i\varphi} \cdot \sin^3 \theta
\end{align}
\]</span></p>
<p>Complex-valued functions are not directly usable in our applications. The real basis of SH is defined as follows: <span class="math display">\[
\mathrm{Y}_{\ell}^{m}(\theta, \varphi)=\begin{cases} \sqrt{2}(-1)^{m} \operatorname{Im}[Y_{\ell}^{|m|}] &amp; \text{if } m&lt;0 \\ Y_{\ell}^{0} &amp; \text{if } m=0 \\ \sqrt{2}(-1)^{m} \operatorname{Re}[Y_{\ell}^{m}] &amp; \text{if } m&gt;0 \end{cases}
\]</span> Below are visualizations of the real SH for different <span class="math inline">\(l\)</span> and <span class="math inline">\(m\)</span> values. Red and blue represent positive and negative regions, respectively.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 5%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 13%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th style="text-align: center;"><span class="math inline">\(m=-3\)</span></th>
<th style="text-align: center;"><span class="math inline">\(m=-2\)</span></th>
<th style="text-align: center;"><span class="math inline">\(m=-1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(m=0\)</span></th>
<th style="text-align: center;"><span class="math inline">\(m=1\)</span></th>
<th style="text-align: center;"><span class="math inline">\(m=2\)</span></th>
<th style="text-align: center;"><span class="math inline">\(m=3\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(l=0\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><img src="l0m0.png" class="img-fluid"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><span class="math inline">\(l=1\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><img src="l1m_1.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l1m0.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l1m1.png" class="img-fluid"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(l=2\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><img src="l2m_2.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l2m_1.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l2m0.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l2m1.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l2m2.png" class="img-fluid"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td><span class="math inline">\(l=3\)</span></td>
<td style="text-align: center;"><img src="l3m_3.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l3m_2.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l3m_1.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l3m0.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l3m1.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l3m2.png" class="img-fluid"></td>
<td style="text-align: center;"><img src="l3m3.png" class="img-fluid"></td>
</tr>
</tbody>
</table>
<p>The above visualizations were created using Colab: <a href="https://colab.research.google.com/drive/1h6gI3gn1ZXvsNCQYyDJ0DxFXXwH0VowB"><img src="https://colab.research.google.com/assets/colab-badge.svg" class="img-fluid"></a>.</p>
</section>
</section>
<section id="rendering" class="level1">
<h1>Rendering</h1>
<p>The original <a href="https://arxiv.org/abs/2308.04079">3DGS paper</a> uses SH of degree 2 (<span class="math inline">\(l = 2\)</span>), which requires 9 coefficients per color channel for a total of 27 SH coefficients per Gaussian. More generally, given a viewing angle <span class="math inline">\((\theta, \varphi)\)</span> and coefficients <span class="math inline">\(k_l^m\)</span>, the color can be determined by <span class="math display">\[
c(\theta,\varphi,k_l^m)=\sigma\left(\sum_{l=0}^L\sum_{m=-l}^l k_l^m \mathrm{Y}_{l}^{m}(\theta, \varphi)\right)
\tag{1}
\]</span> where <span class="math inline">\(\sigma\)</span> is the sigmoid function, used to normalize the values to <span class="math inline">\([0, 1]\)</span>.</p>
</section>
<section id="experiment" class="level1">
<h1>Experiment</h1>
<p>In this section, we use a small example to show how SH can approximate spherical functions. We use a world map as the target spherical function we aim to approximate. The picture is shown below. We use an equirectangular projection for visualization purposes, but the computation is performed on the surface of a sphere.</p>
<p><img src="earth.jpg" class="img-fluid"></p>
<p>Next, we sample 500 points on the sphere. These are the locations at which we approximate the target function with SH. How do we uniformly sample points on a sphere? There are many methods; here we use a simple method called the <a href="https://observablehq.com/@meetamit/fibonacci-lattices">Fibonacci lattice</a>.</p>
<p>We randomly initialize the coefficients <span class="math inline">\(k_l^m\)</span> and compute the values at the 500 points using Equation (1). We then compare these values with the target function to compute the <span class="math inline">\(l2\)</span> loss. We run the Adam optimizer to iteratively find optimal values for <span class="math inline">\(k_l^m\)</span>. Detailed code is in the repository: <a href="https://github.com/tomondev/spherical-harmonics-example"><img src="https://img.shields.io/static/v1.svg?logo=github&amp;label=Repo&amp;message=View%20On%20Github&amp;color=lightgrey" class="img-fluid" alt="View on GitHub"></a></p>
<p>For each experiment, we sample 500 points and run 5,000 iterations. The results below show the approximated image at iteration 5,000 for <span class="math inline">\(L = 10\)</span>, <span class="math inline">\(20\)</span>, and <span class="math inline">\(30\)</span>. We can see that larger <span class="math inline">\(L\)</span> helps recover more details in the approximated image.</p>
<p>L = 10 <img src="output_5000_d10.png" class="img-fluid"></p>
<p>L = 20 <img src="output_5000_d20.png" class="img-fluid"></p>
<p>L = 30 <img src="output_5000_d30.png" class="img-fluid"></p>
<section id="the-first-image-is-the-ground-truth.-the-sequence-beginning-with-the-second-image-shows-how-the-appoximated-image-evolves-as-training-progresses." class="level3">
<h3 class="anchored" data-anchor-id="the-first-image-is-the-ground-truth.-the-sequence-beginning-with-the-second-image-shows-how-the-appoximated-image-evolves-as-training-progresses.">The first image is the ground truth. The sequence beginning with the second image shows how the appoximated image evolves as training progresses.</h3>
<p><img src="progression.png" class="img-fluid"></p>
</section>
<section id="animation-showing-the-training-progress." class="level3">
<h3 class="anchored" data-anchor-id="animation-showing-the-training-progress.">Animation showing the training progress.</h3>
<p><img src="progression.gif" class="img-fluid"></p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<ol type="1">
<li><a href="https://arxiv.org/abs/2308.04079">3D Gaussian Splatting for Real-Time Radiance Field Rendering</a></li>
<li><a href="https://arxiv.org/pdf/2103.14024">PlenOctrees for Real-time Rendering of Neural Radiance Fields</a></li>
<li><a href="https://3dvar.com/Green2003Spherical.pdf">Spherical Harmonic Lighting: The Gritty Details</a></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/tomondev\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>