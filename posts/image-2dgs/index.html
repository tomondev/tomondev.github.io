<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tom">
<meta name="dcterms.date" content="2025-08-01">

<title>A Toy Example of 2D Gaussian Splatting in JAX – On Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-528204117fddde345da99c6598249467.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">On Notes</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">A Toy Example of 2D Gaussian Splatting in JAX</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Tom </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">August 1, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><a href="https://huggingface.co/blog/gaussian-splatting">3D Gaussian Splatting</a> (3DGS) is a rendering technique for photorealistic view synthesis. In this post, we will create a toy example of 2D Gaussian splatting (2DGS). We will train a 2DGS model to render a small image. This 2D version strips away much of the complexity found in 3DGS, making the core ideas much easier to understand.</p>
<p>Here are some key differences between 2DGS and 3DGS:</p>
<ul>
<li>A single image is sufficient to train a 2DGS model, unlike 3DGS, which often requires multiple views.</li>
<li>2DGS does not require handling camera poses or parameters.</li>
<li>In 2DGS, a single color is assigned to each Gaussian, whereas 3DGS uses spherical harmonics to model view-dependent appearance.</li>
<li>For 2DGS, pixel colors are determined by a simple weighted average of Gaussian colors, eliminating the need for depth ordering or opacity attributes, which are required in 3DGS’s alpha-blended rendering.</li>
</ul>
<section id="problem-formulation" class="level2">
<h2 class="anchored" data-anchor-id="problem-formulation">Problem Formulation</h2>
<p>A 2D Gaussian has a mean vector <span class="math inline">\(\mu\in\mathbb{R}^2\)</span> and a covariance matrix <span class="math inline">\(\Sigma\in\mathbb{R}^{2 \times 2}\)</span>. The density is expressed as <span class="math display">\[
G(x)=\exp\left(-\dfrac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\right)
\]</span> where <span class="math inline">\(x\)</span> is the pixel location. Note that this is not a probability density, so it doesn’t need to be normalized.</p>
<p>Usually, people use <span class="math inline">\(\Sigma=RSS^TR^T\)</span> to ensure <span class="math inline">\(\Sigma\)</span> is always positive semi-definite during training. <span class="math inline">\(R\in\mathbb{R}^{2\times2}\)</span> is a rotation matrix, and <span class="math inline">\(S\in\mathbb{R}^{2\times2}\)</span> is a scaling matrix. <span class="math inline">\(R\)</span> is parameterized by an angle <span class="math inline">\(\theta\in[0,\pi]\)</span>, and <span class="math inline">\(S\)</span> is determined by a scaling vector <span class="math inline">\(s\in\mathbb{R}^2_+\)</span>.</p>
<p>Lastly, we need to assign a color to each Gaussian. Unlike 3DGS, which uses spherical harmonics, we only need a vector <span class="math inline">\(c\in\mathbb{R}^3\)</span> to represent the RGB values of a 2D Gaussian.</p>
<p>To summarize, each 2D Gaussian primitive is characterized by <span class="math inline">\((\mu, \theta, s, c)\)</span>. Each pixel value <span class="math inline">\(\mathbf{RGB}(x)\)</span> is determined by a weighted average of all the Gaussians where the weights are computed by the density function <span class="math inline">\(G(x)\)</span>: <span class="math display">\[
\mathbf{RGB}(x)=\dfrac{1}{\sum_i G_i(x)}\sum_i G_i(x)c_i
\]</span></p>
</section>
<section id="target-image" class="level2">
<h2 class="anchored" data-anchor-id="target-image">Target Image</h2>
<p>Here is our target image with a size of 128x128.</p>
<p><img src="input.jpg" class="img-fluid"></p>
</section>
<section id="implementation" class="level2">
<h2 class="anchored" data-anchor-id="implementation">Implementation</h2>
<p>First, we randomly initialize all the Gaussian parameters. We use a total of 5000 Gaussians. Using more Gaussians improves quality but also increases memory usage.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a>_GS_NUM <span class="op">=</span> <span class="dv">5000</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>key <span class="op">=</span> jax.random.PRNGKey(<span class="dv">0</span>)</span>
<span id="cb1-3"><a href="#cb1-3"></a>key_mu, key_theta, key_scaling, key_color <span class="op">=</span> jax.random.split(key, <span class="dv">4</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a>mu_array <span class="op">=</span> jax.random.uniform(key_mu, (_GS_NUM, <span class="dv">2</span>), minval<span class="op">=</span><span class="fl">0.0</span>, maxval<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb1-5"><a href="#cb1-5"></a>theta_array <span class="op">=</span> jax.random.uniform(key_theta, (_GS_NUM, <span class="dv">1</span>), minval<span class="op">=</span><span class="fl">0.0</span>, maxval<span class="op">=</span>jnp.pi)</span>
<span id="cb1-6"><a href="#cb1-6"></a>scaling_array <span class="op">=</span> jax.random.uniform(</span>
<span id="cb1-7"><a href="#cb1-7"></a>    key_scaling, (_GS_NUM, <span class="dv">2</span>), minval<span class="op">=</span><span class="fl">0.0</span>, maxval<span class="op">=</span><span class="fl">0.1</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>)</span>
<span id="cb1-9"><a href="#cb1-9"></a>color_array <span class="op">=</span> jax.random.uniform(key_color, (_GS_NUM, <span class="dv">3</span>), minval<span class="op">=</span><span class="fl">0.0</span>, maxval<span class="op">=</span><span class="fl">255.0</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Next, we implement the key part of the training code: a function to compute the Gaussian density. We will implement the function for computing the density of a single Gaussian at a single pixel location. We then use three layers of <code>jax.vmap</code> to vectorize the function, allowing a single call to compute the density for all Gaussians at all locations.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a><span class="at">@partial</span>(jax.vmap, in_axes<span class="op">=</span>(<span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>, <span class="dv">0</span>))  <span class="co"># map over height dimension</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="at">@partial</span>(jax.vmap, in_axes<span class="op">=</span>(<span class="va">None</span>, <span class="va">None</span>, <span class="va">None</span>, <span class="dv">0</span>))  <span class="co"># map over width dimension</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="at">@partial</span>(jax.vmap, in_axes<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="va">None</span>))  <span class="co"># map over gaussians</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="kw">def</span> compute_gaussians(mu, theta, scaling, coord):</span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="co">"""Compute the value of a single Gaussian at the given coordinate."""</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>    <span class="co"># rotation matrix</span></span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="co"># clip theta to the range [0, pi]</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    theta <span class="op">=</span> jnp.clip(theta, <span class="fl">0.0</span>, jnp.pi)</span>
<span id="cb2-9"><a href="#cb2-9"></a>    c <span class="op">=</span> jnp.cos(theta[<span class="dv">0</span>])</span>
<span id="cb2-10"><a href="#cb2-10"></a>    s <span class="op">=</span> jnp.sin(theta[<span class="dv">0</span>])</span>
<span id="cb2-11"><a href="#cb2-11"></a>    R <span class="op">=</span> jnp.array([[c, <span class="op">-</span>s], [s, c]])</span>
<span id="cb2-12"><a href="#cb2-12"></a>    <span class="co"># scaling matrix</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>    <span class="co"># clip scaling to be positive</span></span>
<span id="cb2-14"><a href="#cb2-14"></a>    scaling <span class="op">=</span> jnp.clip(scaling, <span class="bu">min</span><span class="op">=</span><span class="fl">1e-6</span>, <span class="bu">max</span><span class="op">=</span><span class="va">None</span>)</span>
<span id="cb2-15"><a href="#cb2-15"></a>    S <span class="op">=</span> jnp.diag(scaling)</span>
<span id="cb2-16"><a href="#cb2-16"></a>    <span class="co"># covariance matrix</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>    <span class="co"># add small value for numerical stability</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>    Sigma <span class="op">=</span> R <span class="op">@</span> S <span class="op">@</span> S <span class="op">@</span> R.T <span class="op">+</span> <span class="fl">1e-6</span> <span class="op">*</span> jnp.eye(<span class="dv">2</span>)</span>
<span id="cb2-19"><a href="#cb2-19"></a>    diff <span class="op">=</span> coord <span class="op">-</span> mu</span>
<span id="cb2-20"><a href="#cb2-20"></a>    exponent <span class="op">=</span> <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span> diff <span class="op">@</span> jnp.linalg.inv(Sigma) <span class="op">@</span> diff.T</span>
<span id="cb2-21"><a href="#cb2-21"></a>    <span class="cf">return</span> jnp.exp(exponent)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With <code>compute_gaussians</code> implemented, it is easy to finish the rendering function. It basically computes a weighted average of all Gaussian colors for each pixel. <code>@jax.jit</code> is needed to compile and accelerate the rendering call.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a><span class="at">@jax.jit</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="kw">def</span> render_image(mu_array, theta_array, scaling_array, color_array, coords):</span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="co">"""Render the image from the parameters."""</span></span>
<span id="cb3-4"><a href="#cb3-4"></a>    gaussians <span class="op">=</span> compute_gaussians(mu_array, theta_array, scaling_array, coords)</span>
<span id="cb3-5"><a href="#cb3-5"></a>    <span class="co"># weighted average of gaussians</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>    rendered_image <span class="op">=</span> jnp.matmul(gaussians, color_array) <span class="op">/</span> (</span>
<span id="cb3-7"><a href="#cb3-7"></a>        jnp.<span class="bu">sum</span>(gaussians, axis<span class="op">=-</span><span class="dv">1</span>, keepdims<span class="op">=</span><span class="va">True</span>) <span class="op">+</span> <span class="fl">1e-6</span></span>
<span id="cb3-8"><a href="#cb3-8"></a>    )</span>
<span id="cb3-9"><a href="#cb3-9"></a>    rendered_image <span class="op">=</span> jnp.clip(rendered_image, <span class="dv">0</span>, <span class="dv">255</span>)</span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="cf">return</span> rendered_image</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>With all the code above, it is now straightforward to implement the training loop in the <code>main</code> function. We can summarize the training code as follows:</p>
<ul>
<li>Initialize the gaussians</li>
<li>loop
<ul>
<li>render the image</li>
<li>compute l1 loss and gradients</li>
<li>update gaussian parameters</li>
</ul></li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a>_SIZE <span class="op">=</span> <span class="dv">128</span></span>
<span id="cb4-2"><a href="#cb4-2"></a>_ITERATIONS <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>_GS_INITIAL_NUM <span class="op">=</span> <span class="dv">5000</span></span>
<span id="cb4-4"><a href="#cb4-4"></a></span>
<span id="cb4-5"><a href="#cb4-5"></a><span class="kw">def</span> main():</span>
<span id="cb4-6"><a href="#cb4-6"></a>    img <span class="op">=</span> Image.<span class="bu">open</span>(<span class="st">"input.jpg"</span>)</span>
<span id="cb4-7"><a href="#cb4-7"></a>    img_array <span class="op">=</span> np.array(img)</span>
<span id="cb4-8"><a href="#cb4-8"></a>    key <span class="op">=</span> jax.random.PRNGKey(<span class="dv">0</span>)</span>
<span id="cb4-9"><a href="#cb4-9"></a>    key_mu, key_theta, key_scaling, key_color <span class="op">=</span> jax.random.split(key, <span class="dv">4</span>)</span>
<span id="cb4-10"><a href="#cb4-10"></a>    mu_array <span class="op">=</span> jax.random.uniform(key_mu, (_GS_NUM, <span class="dv">2</span>), minval<span class="op">=</span><span class="fl">0.0</span>, maxval<span class="op">=</span><span class="fl">1.0</span>)</span>
<span id="cb4-11"><a href="#cb4-11"></a>    theta_array <span class="op">=</span> jax.random.uniform(key_theta, (_GS_NUM, <span class="dv">1</span>), minval<span class="op">=</span><span class="fl">0.0</span>, maxval<span class="op">=</span>jnp.pi)</span>
<span id="cb4-12"><a href="#cb4-12"></a>    scaling_array <span class="op">=</span> jax.random.uniform(</span>
<span id="cb4-13"><a href="#cb4-13"></a>        key_scaling, (_GS_NUM, <span class="dv">2</span>), minval<span class="op">=</span><span class="fl">0.0</span>, maxval<span class="op">=</span><span class="fl">0.1</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>    )</span>
<span id="cb4-15"><a href="#cb4-15"></a>    color_array <span class="op">=</span> jax.random.uniform(key_color, (_GS_NUM, <span class="dv">3</span>), minval<span class="op">=</span><span class="fl">0.0</span>, maxval<span class="op">=</span><span class="fl">255.0</span>)</span>
<span id="cb4-16"><a href="#cb4-16"></a></span>
<span id="cb4-17"><a href="#cb4-17"></a>    <span class="co"># create a grid of x, y coordinates</span></span>
<span id="cb4-18"><a href="#cb4-18"></a>    x <span class="op">=</span> jnp.linspace(<span class="dv">0</span>, <span class="fl">1.0</span>, _SIZE)</span>
<span id="cb4-19"><a href="#cb4-19"></a>    y <span class="op">=</span> jnp.linspace(<span class="dv">0</span>, <span class="fl">1.0</span>, _SIZE)</span>
<span id="cb4-20"><a href="#cb4-20"></a>    xx, yy <span class="op">=</span> jnp.meshgrid(x, y)</span>
<span id="cb4-21"><a href="#cb4-21"></a>    coords <span class="op">=</span> jnp.stack([xx, yy], axis<span class="op">=-</span><span class="dv">1</span>)  <span class="co"># shape (_SIZE, _SIZE, 2)</span></span>
<span id="cb4-22"><a href="#cb4-22"></a></span>
<span id="cb4-23"><a href="#cb4-23"></a>    learning_rate <span class="op">=</span> <span class="fl">0.001</span></span>
<span id="cb4-24"><a href="#cb4-24"></a>    optimizer <span class="op">=</span> optax.adam(learning_rate)</span>
<span id="cb4-25"><a href="#cb4-25"></a>    params <span class="op">=</span> (mu_array, theta_array, scaling_array, color_array)</span>
<span id="cb4-26"><a href="#cb4-26"></a>    opt_state <span class="op">=</span> optimizer.init(params)</span>
<span id="cb4-27"><a href="#cb4-27"></a></span>
<span id="cb4-28"><a href="#cb4-28"></a>    <span class="kw">def</span> loss_fn(params):</span>
<span id="cb4-29"><a href="#cb4-29"></a>        rendered <span class="op">=</span> render_image(</span>
<span id="cb4-30"><a href="#cb4-30"></a>            <span class="op">*</span>params,</span>
<span id="cb4-31"><a href="#cb4-31"></a>            coords,</span>
<span id="cb4-32"><a href="#cb4-32"></a>        )</span>
<span id="cb4-33"><a href="#cb4-33"></a>        <span class="cf">return</span> jnp.mean(jnp.<span class="bu">abs</span>(rendered <span class="op">-</span> img_array))</span>
<span id="cb4-34"><a href="#cb4-34"></a></span>
<span id="cb4-35"><a href="#cb4-35"></a>    <span class="kw">def</span> update(params, opt_state):</span>
<span id="cb4-36"><a href="#cb4-36"></a>        grads <span class="op">=</span> jax.grad(loss_fn)(params)</span>
<span id="cb4-37"><a href="#cb4-37"></a>        updates, opt_state <span class="op">=</span> optimizer.update(grads, opt_state)</span>
<span id="cb4-38"><a href="#cb4-38"></a>        new_params <span class="op">=</span> optax.apply_updates(params, updates)</span>
<span id="cb4-39"><a href="#cb4-39"></a>        <span class="cf">return</span> new_params, opt_state</span>
<span id="cb4-40"><a href="#cb4-40"></a></span>
<span id="cb4-41"><a href="#cb4-41"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(_ITERATIONS):</span>
<span id="cb4-42"><a href="#cb4-42"></a>        params, opt_state <span class="op">=</span> update(params, opt_state)</span>
<span id="cb4-43"><a href="#cb4-43"></a>        current_loss <span class="op">=</span> loss_fn(params)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Please see the complete code in <a href="https://github.com/tomondev/image-gs-toy-example">this repo</a>.</p>
</section>
<section id="results" class="level2">
<h2 class="anchored" data-anchor-id="results">Results</h2>
<p>The first image is the target image. The last image is from iteration 1000.</p>
<p><img src="progression.png" class="img-fluid"></p>
<section id="animation" class="level3">
<h3 class="anchored" data-anchor-id="animation">animation</h3>
<p><img src="progression.gif" class="img-fluid"></p>
</section>
</section>
<section id="important-notes" class="level2">
<h2 class="anchored" data-anchor-id="important-notes">Important Notes</h2>
<p>The current code implementation is inefficient and overly simplistic. Improvements can be made in the following aspects:</p>
<p>To enhance efficiency, we can avoid evaluating all Gaussians for every pixel. Gaussians located far from a pixel contribute negligibly to its color. A more efficient approach involves selecting the K Gaussians with the highest density at a given pixel. However, identifying and managing K Gaussians for each individual pixel might be too resource-intensive. A more pragmatic solution is to generate K Gaussians for a specific tile, while ensuring that Gaussians spanning multiple tiles are managed appropriately.</p>
<p>It is not optimal to initialize the Gaussians randomly. Instead, we can initialize the geometry and color of the Gaussians according to pixel intensity and gradients. This will likely lead to faster convergence and better reconstruction quality.</p>
<p>Last but not least, the number of Gaussians doesn’t have to be fixed. In each iteration, we can remove some Gaussians whose contributions are negligible and create new Gaussians at pixels where reconstruction errors are high.</p>
<p>Overall, this is a simple example that gives you an idea of how Gaussian splatting works. To render a high-quality image efficiently, there are many improvements that can be added.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/tomondev\.github\.io\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>